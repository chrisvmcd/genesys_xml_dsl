<?xml version="1.0" encoding="UTF-8"?>
<project name="Groovy and Java Bootstrap" default="jar" basedir=".">
	<property name="src.dir" value="src"/>
	<property name="build.dir" value="build"/>
	<property name="dist.dir" value="dist"/>
	<property name="lib.dir" value="lib"/>
	<property name="jarName" value="GroovyArchitecture"/>
	<property name="report.dir" value="reports"/>
	<property name="junit.data.dir" value="${report.dir}/junit/data"/>
	<property name="junit.report.dir" value="${report.dir}/junit/html"/>
	

	<!--========================================== 
		classpaths
	==========================================-->
	<!-- This allows jars to be added to the lib directory
		and they will automatically get included into the build. When mixing
		Java and Groovy source in the same project, it is necessary to add the
		build directory to y
	 -->
	<path id="lib.classpath">
		<fileset dir="${lib.dir}">
			<include name="**/*.jar"/>
			<exclude name="**/cobertura/*.jar"/>
		</fileset>
	</path>
	<path id="build.classpath">
		<pathelement location="${build.dir}"/>
		<path refid="lib.classpath"/>
	</path>
	<path id="runtime.classpath">
		<pathelement location="${build.dir}"/>
		<path refid="lib.classpath"/>
	</path>
	<path id="cobertura.classpath">
		<fileset dir="${lib.dir}/cobertura" includes="**/*.jar"/>
	</path>
	
	<!--========================================== 
		pattern set for resources that are stored
		in the src directory that should be
		copied into the runtime build dir. This is useful making sure that
		files like log4j.properties, Spring context.xml, and Hibernate
		config.xml get copied into the build area.
	==========================================-->
	<patternset id="resources.ps">
	  <include name="**/*.txt"/>
	  <include name="**/*.xml"/>
	  <include name="**/*.properties"/>
	  <exclude name="**/*.groovy"/>
	</patternset>
	
	<!--========================================== 
			external tasks  
	==========================================-->

	<!-- add support for compiling Groovy source to byte code-->
	<taskdef name="groovyc"	classpathref="lib.classpath"   
			classname="org.codehaus.groovy.ant.Groovyc"/>

	<!-- add support for embedding Groovy code inside a target  -->
	<taskdef name="groovy" classpathref="lib.classpath" 
		classname="org.codehaus.groovy.ant.Groovy"/>
	


	<!-- create output directories 	-->
	<target name="init">
		<mkdir dir="${build.dir}"/>
		<mkdir dir="${dist.dir}"/>
	</target>

	<!--========================================== 
			clean
	==========================================-->
	<target name="clean" description="Remove all generated files.">
		<delete dir="${build.dir}"/>
		<delete dir="${dist.dir}"/>
	</target>

	<!--========================================== 
		This target supports compilation for project that includes
		both Java and Groovy source code. If your project is primarily Groovy and it uses some
		Java utilities, it is necessary to compile the Java sources first so that those compiled 
		classes are available and can be resolved during Groovy compilation. Depending on your project,
		it may necessary to change the order of compilation. If the your project is mostly Java,
		with some utilties being written in Groovy, it will be necessary to compile the Groovy soource
		so those files are available during Java compilation.
		
		Also note that the groovyc task has build.classpath instead of lib.classpath .  This is
		important. Without this, the groovy compilier won't pick up the Java classes that are 
		part of the project sitting in the build directory.
	==============================================-->
	<target name="compile" depends="init" description="invoke groovy compiler and java compiler">
		<javac srcdir="${src.dir}" destdir="${build.dir}" debug="true">
			<classpath refid="lib.classpath"/>
		</javac>
		<groovyc srcdir="${src.dir}" destdir="${build.dir}">
			<classpath refid="build.classpath"/>
		</groovyc>
	</target>
	
	<target name="testCsvReader">
		<antcall target="runSingleJunitTest">
			<param name="testcase" value="org.hickey.io.CsvReaderTest"/>
		</antcall>
	</target>
	
	<target name="run-single-junit-test" depends="compile" >
		<junit fork="true" haltonfailure="yes">
			<classpath refid="runtime.classpath"/>
			<formatter type="plain" usefile="false"/>
			<test name="${testcase}"/>
		</junit>
	</target>
	<!--
		All of our tests written in Groovy extend GroovyTestCase extends Junit's TestCase. 
		Once Groovy tests are compiled into .class files, they are handled just
		like any other Junit test. Whether running a one JUnit test or all of them using the
		batchtest option, the junit task doesn't know about the source that created .class files;
		it only cares that the .class file is there.
		
		For Groovy projects, it's good the follow the convention of adding Test to the end of the 
		class name. I have seen some people recommend and standard of putting at the beginning.
		The reason for this is that closures used inside of Groovy will create an separate class.
		If I have a Groovy test class called TestCsvReader that has one closure, the compiler will create
		two files: TestCsvReader.class and TestCsvReader$1.class. We definately don't want to batch test
		the files with a $ in their name.
		
		The formatter type="xml will create xml files that have the test result details in them. These
		xml files are used by the junitreport ant task to create html files that allow a user to
		browse the reports.
	-->
<target name="junit-haltonfailure-false">
	<property name="haltOnFailureFlag" value="false"/>
</target>
	
	<target name="run-all-junit-tests" depends="compile">
		<!-- set default classpath if not already set -->
		<property name="junitClasspathId" value="runtime.classpath"/>
		<property name="haltOnFailureFlag" value="true"/>
		
		<!-- clean up old junit xml files -->
		<delete dir="${junit.data.dir}"/>
		<mkdir dir="${junit.data.dir}"/>
		
		<!-- run the tests -->
		<junit printsummary="yes" haltonfailure="${haltOnFailureFlag}" 
			failureproperty="testsDidNotPass" fork="yes">
			<formatter type="plain" usefile="false"/>
			<formatter type="xml"/>
			<batchtest todir="${junit.data.dir}">
			  <fileset dir="${build.dir}" includes="**/*Test.class" />
			</batchtest>
			<classpath refid="${junitClasspathId}"/>
		</junit>
	</target>
	
<target name="junit-report" depends="junit-haltonfailure-false,run-all-junit-tests" 
	description="Run all unit tests and create Junit Report">
	
	<!-- clean up old html Junit report files -->
	<delete dir="${junit.report.dir}"/>
	<mkdir dir="${junit.report.dir}"/>
	
	<junitreport todir="${junit.report.dir}">
		<fileset dir="${junit.data.dir}">
			<include name="TEST-*.xml"/>
		</fileset>
		<report todir="${junit.report.dir}"/>
	</junitreport>
	<fail if="testsDidNotPass"/>
</target>

	<target name="test-runner"
		description="GUI for picking a Junit test to run">
		<groovy src="./TestRunner.groovy"/>
		<waitfor maxwait="10" maxwaitunit="second">
			<isset property="testcase" />
		</waitfor>
		<fail unless="testcase">No test selected</fail>
		<antcall target="run-single-junit-test"/>
	</target>
	

	<target name="jar" depends="clean,compile,junit-report" description="creates jar in the dist directory">
		<jar jarfile="${dist.dir}/${jarName}.jar" basedir="${build.dir}"/>			
	</target>

	<target name="architecture-check">
		<java classname="be.devijver.examples.groovy.builder.architecture.GroovyArchitecture">
			<classpath refid="runtime.classpath"/>
		</java>
	</target>

</project>